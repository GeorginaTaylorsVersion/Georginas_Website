{"pageProps":{"term":"1B","course":"CS 116","unit":"7. Efficiency","note":"Module 7 Efficiency 1a9115b71c1180a28752e4f5c452465f","noteContent":"<h1>Module 7: Efficiency</h1>\n<p><strong>worst run time summary</strong></p>\n<p>O(1):\nBasic opertations (+-*/, return)\nString operations: len(s), s[k]\nList operations: len(L), L[k], L[3:5], L.append(x), range(n)</p>\n<p>O(n):\nString operations: s + t, count, find, etc, s == t, print(s), s = input(), t in s\nList operations: L == M, L + M, L*k, L + [x], sum(L), max(L), L[1:], list(range(n)), [x]*n, count, index, remove, L.extend(M), e in L</p>\n<p>other: L.sort () -> O(nlogn)</p>\n<p>Abstract List Functions:\nmap(f, L), filter(f, L) depends on :</p>\n<ul>\n<li>The length of L</li>\n<li>The runtime of f (we apply the runtime of f to a list of len(L))</li>\n</ul>\n<p>Loops:</p>\n<ul>\n<li>In general, O(n) time</li>\n<li>code inside the loop that slows down the runtime (e.g. L += x, nested loop, abstract list function)</li>\n<li>how many times the loop executes (e.g. for i in range(5), loop stops before n iterations such as returning inside a loop). These might result in a faster runtime</li>\n</ul>\n<p>Recursions:</p>\n<ul>\n<li>look at the return statements, (e.g. return fn(m, L[1:]) takes O(n) + T(n-1), O(n) for slicing and T(n-1) for going through 1 element less)</li>\n</ul>\n<p>linear search = O(n)\nbinary seach = O(logn)\nselection sort = O(n^2)\ninsertion sort = O(n^2) (O(n) on almost sorted lists)\nmerge sort = O(nlogn)</p>\n<p>Dictionaries:</p>\n<ul>\n<li>list(d.keys()) and list(d.values()) = O(n)</li>\n<li>d.pop(k), removes k from d and returns the value at d[k] = O(1)</li>\n<li>index with keys (Any type) = O(1)</li>\n<li>k in d = O(1)</li>\n</ul>\n<pre><code class=\"python-code-box\">def mult_table(n):\n  table = [0]*n #O(n)\n  row = 0 #O(1)\n  columns = list(range(n)) #O(n)\n  while row &#x3C; n: #O(1) --> while loop tuns n cycles\n    this_row = [] #O(1)\n    for c in columns: #O(n) --> for loop stays O(n)\n      this_row.append((row+1)*(c+1)) #O(1) because append is a constant term\n    table[row] = this_row #O(1)\n    row = row + 1 #O(1)\n  return table #O(1)\n  ## O(n) + O(1) + O(n)1+ nO(n) + O(1) = O(n**2)\n</code></pre>\n<pre><code class=\"python-code-box\">def mult_table(n):\n  table = [0]*n #O(n)\n  row = 0 #O(1)\n  columns = list(range(n)) #O(n)\n  while row &#x3C; n: #O(1) --> while loop tuns n cycles\n    this_row = [] #O(1)\n    for c in columns: #O(n) --> for loop becomes O(n**2)\n      this_row += [(row+1) * (c+1)] #O(n)\n    table[row] = this_row #O(1)\n    row = row + 1 #O(1)\n  return table #O(1)\n  ## O(n) + O(1) + O(n)1+ nO(n**2) + O(1) = O(n**3)\n</code></pre>","noteData":{},"unitTitle":"7. Efficiency"},"__N_SSG":true}