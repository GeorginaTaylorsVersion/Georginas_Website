{"pageProps":{"term":"1B","course":"CS 116","unit":"5. Types of Recursion","note":"Module 5 Types of Recursion 1a9115b71c118099b8f2d8916dea058c","noteContent":"<h1>Module 5: Types of Recursion</h1>\n<p>Accumulative Approach to Recursion (structural recursion with an accumulator)</p>\n<ul>\n<li>A helper function is required\n<ul>\n<li>helper function requires at least two parameters</li>\n<li>One to keep track of what has been done on previous recursive calls (the \"accumulator\")</li>\n<li>One to keep track of what remaining to be processed (used to identify the base or stopping cases)</li>\n</ul>\n</li>\n<li>The main function is a wrapper function that sets the initial value of the accumulator(s).</li>\n<li>The main function may also handle special cases.</li>\n</ul>\n<p>Template:</p>\n<pre><code class=\"python-code-box\">def acc_template(acc, remaining, *args):\n    # if at stopping case of remaining:\n    #    return (answer using acc)\n    # else:\n    #    return acc_template(updated-acc,\n    #                       updated-remaining, *args)\n    pass\n\ndef fn(*args):\n    # process result of calling\n    #     acc_template(initial-acc,\n    #                 initial-remaining, *args)\n    # Note: consider special cases, as needed\n    pass\n</code></pre>\n<p>e.g. Fibonacci Sequence:</p>\n<p>Original:</p>\n<pre><code class=\"python-code-box\">def fib(n):\n    '''returns nth Fibonacci number\n    fib: Nat -> Nat\n    Example: fib(1) => 1,\n            fib(10) => 55\n    '''\n    if n == 0: return 0\n    elif n == 1: return 1\n    else:\n        return fib(n-1) + fib(n-2)\n</code></pre>\n<p>New:</p>\n<pre><code class=\"python-code-box\">def fib_acc(n, n0, fibs):\n    if n0 >= n: # fib(n) is last list element!\n        return fibs[-1] \n    else:\n        fibs.append(fibs[-1] + fibs[-2]) # fib(n-1) + fib(n-2)\n        return fib_acc(n, n0+1, fibs)\n\ndef fib2(n):\n    if n == 0:\n        return 0\n    else:\n        return fib_acc(n, 1, [0, 1])  # Start with fib(0) and fib(1)\n</code></pre>\n<p>Generative Recursion</p>\n<ul>\n<li>no standard template</li>\n<li>Break the problem into any subproblem(s) that seem natural for the problem</li>\n<li>Determine the base case(s)</li>\n<li>Solve the subproblems, recursively if necessary</li>\n<li>Determine how to combine subproblem solutions to solve the original problem</li>\n<li>TEST! TEST! TEST!</li>\n</ul>\n<p>e.g. gcd</p>\n<pre><code class=\"python-code-box\">def gcd(m, n):\n    if m == 0: return n\n    elif n == 0: return m\n    else: return gcd(n, m % n)\n</code></pre>\n<p>e.g.</p>\n<p>Write the body of a function <code>mult_table(n)</code> that consumes a natural number <code>n</code> and returns the <code>n+1</code> by <code>n+1</code> multiplication table (where each entry in the inner list is equal to the product of which list it is and the inner list position number, or in other words, the product of the row and column numbers). Do not use abstract list functions (you solved this problem with abstract list functions in a previous module). Use accumulative recursion.</p>\n<pre><code class=\"python-code-box\">def build_row_acc(row_num, col_so_far, n, acc):\n    # Base case: if we've processed all columns (0 to n), return completed row\n    if col_so_far > n:\n        return acc\n    else:\n        # Add product of current row and column to the row\n        acc.append(row_num * col_so_far)\n        # Recursively build rest of row, moving to next column\n        return build_row_acc(row_num, col_so_far + 1, n, acc)\n\ndef build_table_acc(row_so_far, n, acc):\n    # Base case: if we've processed all rows (0 to n), return completed table\n    if row_so_far > n:\n        return acc\n    else:\n        # Build a new row starting from column 0 and add it to table\n        acc.append(build_row_acc(row_so_far, 0, n, []))\n        # Recursively build rest of table, moving to next row\n        return build_table_acc(row_so_far + 1, n, acc)\n\ndef mult_table(n):\n    '''Returns an (n+1) by (n+1) multiplication table where each entry\n    is the product of its row and column numbers.\n    \n    mult_table: Nat => (listof (listof Nat))\n    Example: mult_table(2) => [[0,0,0], \n                                [0,1,2], \n                                [0,2,4]]\n    \n    Strategy:\n    1. Start with row 0, building table row by row\n    2. For each row, build it column by column\n    3. Each entry is product of row number and column number\n    '''\n    # Start building table from row 0 with empty accumulator\n    return build_table_acc(0, n, [])\n</code></pre>\n<h3><strong>Reversing a List: Sample Trace</strong></h3>\n<p>If you coded the above problem correctly, the following gives a trace of how your code likely worked assuming your accumulative helper function is called <code>build_reverse</code>:</p>\n<pre><code>reverse([1,2,3,4])\n=> build_reverse([1, 2, 3, 4], [])\n=> build_reverse([2, 3, 4], [1])\n=> build_reverse([3, 4], [2, 1])\n=> build_reverse([4], [3, 2, 1])\n=> build_reverse([], [4, 3, 2, 1])\n=> [4, 3, 2, 1]\n</code></pre>\n<pre><code class=\"python-code-box\">def build_reverse(lst, acc):\n    # Base case: if list is empty, return accumulated result\n    if len(lst) == 0:\n        return acc # this means recursion is done, produce the newest \"acc\"\n    else:\n        # Take rest of list and add current first element to end of accumulator\n        return build_reverse(lst[1:], [lst[0]] + acc) \n        # instead of \"new_lst = lst[0] + build_reverse(lst[1], new_lst)\" do not define new list! \"[lst[0]] + acc\" is going to be recursed as the new list\n        # this means: calling build_reverse, old list is now updated to list after the first element, \n\t\t    # new list is updated to list.append the first element of old list.\n\ndef reverse(L):\n    '''Returns a new list with elements of L in reverse order\n    reverse: (listof X) -> (listof X)\n    Example: reverse([1,2,3,4]) => [4,3,2,1]\n    '''\n    # Start with empty accumulator\n    return build_reverse(L, [])\n    # this calling build_reverse helper function, defining: lst = L, acc(new list) = [] (empty)\n</code></pre>","noteData":{},"unitTitle":"5. Types of Recursion"},"__N_SSG":true}