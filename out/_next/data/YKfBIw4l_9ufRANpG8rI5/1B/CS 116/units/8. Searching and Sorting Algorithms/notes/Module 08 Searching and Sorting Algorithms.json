{"pageProps":{"term":"1B","course":"CS 116","unit":"8. Searching and Sorting Algorithms","note":"Module 08 Searching and Sorting Algorithms","noteContent":"<h1>Module 08: Searching and Sorting Algorithms</h1>\n<p>which to use:\nLinear Search - when list is unsorted\nBinary Search - when list is sorted</p>\n<pre><code class=\"python-code-box\">##Binary Searching\n\ndef binary_search(L, target):\n  beginning = 0\n  end = len(L)\n  while beginning &#x3C; end:\n    mid = (beginning + end)//2\n    if L[mid] == target:\n      return True\n    elif L[mid] > target :\n      end = mid\n    else:\n      beginning = mid + 1\n  return False\n\n#check.expect(\"Test 1\", binary_search([], 4), False)\n#check.expect(\"Test 2\", binary_search([1, 234, 546], 4), False)\n#check.expect(\"Test 3\", binary_search([1, 4, 546], 4), True)\n</code></pre>\n<pre><code class=\"python-code-box\">#Modified Binary Searching Template\ndef binary_search(L, target):\n  beginning = 0\n  end = len(L) - 1 #&#x3C;-- changed line!\n  while beginning > end:\n    mid = (beginning + end)//2\n    if L[mid] == target:\n      return True\n    elif L[mid] > target :\n      end = mid - 1\n    else:\n      beginning = mid - 1\n  return False\n</code></pre>\n<pre><code class=\"python-code-box\">##Selection Sort\n\ndef swap(L, p1, p2):\n  temp = L[p1]\n  L[p1] = L[p2]\n  L[p2] = temp\n  \ndef find_minimum_pos(L, i):\n  return L.index(min(L[i:]),i)\n\ndef selection_sort(L):\n  n = len(L)\n  positions = list(range(n - 1)) #Once we have sorted n-1 elements in an n element list, the nth element is also sorted.\n  for i in positions:\n    min_pos = find_minimum_pos(L, i)\n    swap(L, i, min_pos)\n    \nL = [5, 8, 2, 4, 3, 1, 9, 6]\n#check.expect(\"Test\", selection_sort(L), None)\n#check.expect(\"Test Mutation\", L, [1, 2, 3, 4, 5, 6, 8, 9])\n\n'''\nL = [4,9,6,2,8,5,7]\nfirst interation: [2,9,6,4,8,5,7]\nbefore the last swap: [2, 4, 5, 6, 7, 9, 8]\n'''\n</code></pre>\n<pre><code class=\"python-code-box\">##Insertion Sort\n\ndef swap(L, p1, p2):\n  temp = L[p1]\n  L[p1] = L[p2]\n  L[p2] = temp\n\ndef insert(L, pos):\n  '''\n  Sorts L from 0 to pos inclusive\n  \n  Mutates L\n  \n  insert: (listof Int) Nat -> None\n  Requires: L from 0 to pos-1 is sorted.\n  '''    \n  while pos > 0 and L[pos] &#x3C; L[pos-1]:\n    swap(L, pos, pos - 1)\n    pos = pos - 1\n        \ndef insertion_sort(L):\n  for i in range(1,len(L)):\n    insert(L,i)\n    \nL = [5, 8, 2, 4, 3, 1, 9, 6]\n#check.expect(\"Test\", insertion_sort(L), None)\n#check.expect(\"Test Mutation\", L, [1, 2, 3, 4, 5, 6, 8, 9])\n</code></pre>\n<pre><code class=\"python-code-box\">##Merge Sort\n\ndef merge(L1,L2,L):\n  '''\n  Merges L1 and L2 back into L\n  \n  Effects: Mutates L\n  \n  merge: (listof Int) (listof Int) (listof Int) -> None\n  Requires: \n     L1 and L2 are sorted\n     len(L) == len(L1) + len(L2)\n  \n  Example:\n     If L1, L2 and L are all empty, then\n     merge(L1, L2, L) => None\n     and L is unchanged\n  \n     If L1 = [2, 4, 5, 8] and L2 = [1, 3, 6, 9] \n       and L = [2, 4, 5, 8, 1, 3, 6, 9]\n     merge(L1, L2, L) => None\n     and L is mutated to [1, 2, 3, 4, 5, 6, 8, 9]\n  '''\n  pos1 = 0\n  pos2 = 0\n  posL = 0 \n  while (pos1 &#x3C; len(L1)) and (pos2 &#x3C; len(L2)):\n    if L1[pos1] &#x3C; L2[pos2]:\n      L[posL] = L1[pos1]\n      pos1 += 1\n    else:\n      L[posL] = L2[pos2]\n      pos2 += 1\n    posL += 1\n  while (pos1 &#x3C; len(L1)):\n    L[posL] = L1[pos1]\n    pos1 = pos1 + 1\n    posL = posL + 1\n  while (pos2 &#x3C; len(L2)):\n    L[posL] = L2[pos2]\n    pos2 = pos2 + 1\n    posL = posL + 1\n        \ndef merge_sort(L):\n  if len(L) >= 2: \n    mid = len(L)//2\n    L1 = L[:mid]\n    L2 = L[mid:]\n    merge_sort(L1)\n    merge_sort(L2)\n    merge(L1,L2,L)\n    \nL = [5, 8, 2, 4, 3, 1, 9, 6]\n#check.expect(\"Test\", merge_sort(L), None)\n#check.expect(\"Test Mutation\", L, [1, 2, 3, 4, 5, 6, 8, 9])\n</code></pre>\n<p>Linear Search: Unsorted list → O(n)\nBinary Search: Sorted list → O(logn)\nSelection Sort: O(n^2)\nInsertion Sort: O(n^2)(best case: O(n))\nMerge Sort: O(nlogn)</p>\n<pre><code class=\"python-code-box\">##Built-in Sorting\n\n#sorted does not mutate the list\nL = [[3,4] ,[5,2], [0,0], [2,8], [5,0]]\nN1 = sorted(L, key = lambda M: M[0] + M[1])\n\nLcopy = [[3,4] ,[5,2], [0,0], [2,8], [5,0]]\nN2 = sorted(Lcopy, key = lambda M: M[1], reverse = True)\n\n#sorted which consumes a list and returns a new list in sorted order\nM = [\"cs\", \"116\", \"1s\", \"coo1\"]\nM.sort(key = len)\nM.sort(key = lambda s: s.count('1'), reverse = True)\n\n#Handling Ties\nL = [[3,4] ,[5,2], [0,0], [2,8], [5,0]]\nN1 = sorted(L, key = lambda M: M[0], reverse = True)\nN2 = sorted(N1, key = lambda M: M[0] + M[1])\nprint(L)\nprint(N1)\nprint(N2)\n</code></pre>","noteData":{},"unitTitle":"8. Searching and Sorting Algorithms"},"__N_SSG":true}